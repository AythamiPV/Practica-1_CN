AWSTemplateFormatVersion: "2010-09-09"
Description: "Lambdas CRUD desacopladas para Fishing Store"

Parameters:
  DBHOST:
    Type: String
    Description: Host de la base de datos PostgreSQL
  DBNAME:
    Type: String
    Description: Nombre de la base de datos
  DBUSER:
    Type: String
    Description: Usuario de la base de datos
  DBPASS:
    Type: String
    NoEcho: true
    Description: Contraseña de la base de datos

Resources:

  Pg8000Layer:
    Type: AWS::Lambda::LayerVersion
    Properties:
      LayerName: pg8000-layer
      Description: "Layer con pg8000 para las lambdas"
      Content:
        S3Bucket: aythami23-lambda-layers
        S3Key: lambda_package.zip
      CompatibleRuntimes:
        - python3.11
      LicenseInfo: "MIT"

  # =====================
  # INIT DB LAMBDA
  # =====================
  InitDBLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: init-db-lambda
      Runtime: python3.11
      Handler: index.handler
      Role: !Sub "arn:aws:iam::${AWS::AccountId}:role/LabRole"
      Timeout: 300
      MemorySize: 256
      Environment:
        Variables:
          DB_HOST: !Ref DBHOST
          DB_NAME: !Ref DBNAME
          DB_USER: !Ref DBUSER
          DB_PASS: !Ref DBPASS
      Layers:
        - !Ref Pg8000Layer
      Code:
        ZipFile: |
          import json
          import os
          import pg8000

          def handler(event, context):
              print("Iniciando inicialización de la base de datos...")
              
              try:
                  conn = pg8000.connect(
                      user=os.environ['DB_USER'],
                      password=os.environ['DB_PASS'],
                      host=os.environ['DB_HOST'],
                      database=os.environ['DB_NAME'],
                      port=5432
                  )
                  
                  cursor = conn.cursor()
                  
                  # Script SQL completo
                  sql_script = """
                  -- Crear extensión para UUIDs
                  CREATE EXTENSION IF NOT EXISTS "pgcrypto";

                  -- Crear tabla products
                  CREATE TABLE IF NOT EXISTS products (
                      product_id VARCHAR(255) PRIMARY KEY DEFAULT gen_random_uuid()::text,
                      name VARCHAR(255) NOT NULL,
                      price DECIMAL(10,2) DEFAULT 0,
                      stock INTEGER DEFAULT 0,
                      description TEXT,
                      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                  );

                  -- Insertar datos de prueba
                  INSERT INTO products (product_id, name, price, stock, description) VALUES
                  ('prod-001', 'Caña de Pescar Profesional', 89.99, 15, 'Caña de fibra de carbono de alta resistencia'),
                  ('prod-002', 'Carrete Spinning', 45.50, 20, 'Carrete de precisión con freno ajustable'),
                  ('prod-003', 'Señuelos Artificiales', 12.99, 50, 'Pack de 5 señuelos de diferentes colores')
                  ON CONFLICT (product_id) DO NOTHING;

                  -- Verificar inserción
                  SELECT COUNT(*) as total_products FROM products;
                  """
                  
                  # Ejecutar script
                  cursor.execute(sql_script)
                  result = cursor.fetchone()
                  
                  conn.commit()
                  cursor.close()
                  conn.close()
                  
                  message = f"Base de datos inicializada correctamente. Total productos: {result[0]}"
                  print(message)
                  
                  return {
                      'statusCode': 200,
                      'headers': {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key',
                          'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS'
                      },
                      'body': json.dumps({
                          'message': message,
                          'products_count': result[0],
                          'initialized': True
                      })
                  }
                  
              except Exception as e:
                  error_msg = f"Error inicializando DB: {str(e)}"
                  print(error_msg)
                  return {
                      'statusCode': 500,
                      'headers': {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key',
                          'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS'
                      },
                      'body': json.dumps({'error': error_msg, 'initialized': False})
                  }

  # =====================
  # CREATE PRODUCT LAMBDA
  # =====================
  CreateProductLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: create-product-lambda
      Runtime: python3.11
      Handler: index.handler
      Role: !Sub "arn:aws:iam::${AWS::AccountId}:role/LabRole"
      Timeout: 60
      MemorySize: 256
      Environment:
        Variables:
          DB_HOST: !Ref DBHOST
          DB_NAME: !Ref DBNAME
          DB_USER: !Ref DBUSER
          DB_PASS: !Ref DBPASS
      Layers:
        - !Ref Pg8000Layer
      Code:
        ZipFile: |
          import json
          import os
          import pg8000
          from decimal import Decimal

          def handler(event, context):
              try:
                  body = json.loads(event.get('body', '{}'))
              except json.JSONDecodeError:
                  return {
                      'statusCode': 400,
                      'headers': {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key',
                          'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS'
                      },
                      'body': json.dumps({'error': 'Invalid JSON in request body'})
                  }
              
              # Validaciones básicas
              if not body.get('name'):
                  return {
                      'statusCode': 400,
                      'headers': {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key',
                          'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS'
                      },
                      'body': json.dumps({'error': 'Product name is required'})
                  }
              
              try:
                  conn = pg8000.connect(
                      user=os.environ['DB_USER'],
                      password=os.environ['DB_PASS'],
                      host=os.environ['DB_HOST'],
                      database=os.environ['DB_NAME'],
                      port=5432
                  )
                  
                  cursor = conn.cursor()
                  cursor.execute("""
                      INSERT INTO products (product_id, name, price, stock, description, created_at, updated_at)
                      VALUES (gen_random_uuid()::text, %s, %s, %s, %s, now(), now())
                      RETURNING product_id;
                  """, (
                      body.get('name'),
                      float(body.get('price', 0)) if body.get('price') is not None else 0.0,
                      int(body.get('stock', 0)),
                      body.get('description', '')
                  ))
                  
                  product_id = cursor.fetchone()[0]
                  conn.commit()
                  cursor.close()
                  
                  return {
                      'statusCode': 201,
                      'headers': {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key',
                          'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS'
                      },
                      'body': json.dumps({'product_id': product_id, 'message': 'Product created successfully'})
                  }
                  
              except Exception as e:
                  if 'conn' in locals():
                      conn.rollback()
                  return {
                      'statusCode': 500,
                      'headers': {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key',
                          'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS'
                      },
                      'body': json.dumps({'error': f'Database error: {str(e)}'})
                  }
              finally:
                  if 'conn' in locals():
                      conn.close()

  # =====================
  # UPDATE PRODUCT LAMBDA
  # =====================
  UpdateProductLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: update-product-lambda
      Runtime: python3.11
      Handler: index.handler
      Role: !Sub "arn:aws:iam::${AWS::AccountId}:role/LabRole"
      Timeout: 60
      MemorySize: 256
      Environment:
        Variables:
          DB_HOST: !Ref DBHOST
          DB_NAME: !Ref DBNAME
          DB_USER: !Ref DBUSER
          DB_PASS: !Ref DBPASS
      Layers:
        - !Ref Pg8000Layer
      Code:
        ZipFile: |
          import json
          import os
          import pg8000
          from decimal import Decimal

          def handler(event, context):
              product_id = event.get('pathParameters', {}).get('product_id')
              
              if not product_id:
                  return {
                      'statusCode': 400,
                      'headers': {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key',
                          'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS'
                      },
                      'body': json.dumps({'error': 'product_id is required'})
                  }
              
              try:
                  body = json.loads(event.get('body', '{}'))
              except json.JSONDecodeError:
                  return {
                      'statusCode': 400,
                      'headers': {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key',
                          'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS'
                      },
                      'body': json.dumps({'error': 'Invalid JSON in request body'})
                  }
              
              if not body.get('name'):
                  return {
                      'statusCode': 400,
                      'headers': {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key',
                          'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS'
                      },
                      'body': json.dumps({'error': 'Product name is required'})
                  }

              try:
                  conn = pg8000.connect(
                      user=os.environ['DB_USER'],
                      password=os.environ['DB_PASS'],
                      host=os.environ['DB_HOST'],
                      database=os.environ['DB_NAME'],
                      port=5432
                  )
                  
                  cursor = conn.cursor()
                  cursor.execute("""
                      UPDATE products
                      SET name=%s, price=%s, stock=%s, description=%s, updated_at=now()
                      WHERE product_id=%s
                      RETURNING product_id;
                  """, (
                      body.get('name'),
                      float(body.get('price', 0)) if body.get('price') is not None else 0.0,
                      int(body.get('stock', 0)),
                      body.get('description', ''),
                      product_id
                  ))
                  
                  updated = cursor.fetchone()
                  conn.commit()
                  cursor.close()
                  
                  if not updated:
                      return {
                          'statusCode': 404,
                          'headers': {
                              'Content-Type': 'application/json',
                              'Access-Control-Allow-Origin': '*',
                              'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key',
                              'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS'
                          },
                          'body': json.dumps({'error': 'Product not found'})
                      }
                  
                  return {
                      'statusCode': 200,
                      'headers': {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key',
                          'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS'
                      },
                      'body': json.dumps({'product_id': updated[0], 'message': 'Product updated successfully'})
                  }
                  
              except Exception as e:
                  if 'conn' in locals():
                      conn.rollback()
                  return {
                      'statusCode': 500,
                      'headers': {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key',
                          'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS'
                      },
                      'body': json.dumps({'error': f'Database error: {str(e)}'})
                  }
              finally:
                  if 'conn' in locals():
                      conn.close()

  # =====================
  # DELETE PRODUCT LAMBDA
  # =====================
  DeleteProductLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: delete-product-lambda
      Runtime: python3.11
      Handler: index.handler
      Role: !Sub "arn:aws:iam::${AWS::AccountId}:role/LabRole"
      Timeout: 60
      MemorySize: 256
      Environment:
        Variables:
          DB_HOST: !Ref DBHOST
          DB_NAME: !Ref DBNAME
          DB_USER: !Ref DBUSER
          DB_PASS: !Ref DBPASS
      Layers:
        - !Ref Pg8000Layer
      Code:
        ZipFile: |
          import json
          import os
          import pg8000

          def handler(event, context):
              product_id = event.get('pathParameters', {}).get('product_id')
              
              if not product_id:
                  return {
                      'statusCode': 400,
                      'headers': {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key',
                          'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS'
                      },
                      'body': json.dumps({'error': 'product_id is required'})
                  }

              try:
                  conn = pg8000.connect(
                      user=os.environ['DB_USER'],
                      password=os.environ['DB_PASS'],
                      host=os.environ['DB_HOST'],
                      database=os.environ['DB_NAME'],
                      port=5432
                  )
                  
                  cursor = conn.cursor()
                  cursor.execute("DELETE FROM products WHERE product_id = %s RETURNING product_id", (product_id,))
                  deleted = cursor.fetchone()
                  conn.commit()
                  cursor.close()
                  
                  if not deleted:
                      return {
                          'statusCode': 404,
                          'headers': {
                              'Content-Type': 'application/json',
                              'Access-Control-Allow-Origin': '*',
                              'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key',
                              'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS'
                          },
                          'body': json.dumps({'error': 'Product not found'})
                      }
                  
                  return {
                      'statusCode': 200,
                      'headers': {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key',
                          'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS'
                      },
                      'body': json.dumps({'product_id': deleted[0], 'message': 'Product deleted successfully'})
                  }
                  
              except Exception as e:
                  if 'conn' in locals():
                      conn.rollback()
                  return {
                      'statusCode': 500,
                      'headers': {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key',
                          'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS'
                      },
                      'body': json.dumps({'error': f'Database error: {str(e)}'})
                  }
              finally:
                  if 'conn' in locals():
                      conn.close()

  # ========================
  # GET ALL PRODUCTS LAMBDA (MODIFICADA)
  # ========================
  GetAllProductsLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: get-all-products-lambda
      Runtime: python3.11
      Handler: index.handler
      Role: !Sub "arn:aws:iam::${AWS::AccountId}:role/LabRole"
      Timeout: 60
      MemorySize: 256
      Environment:
        Variables:
          DB_HOST: !Ref DBHOST
          DB_NAME: !Ref DBNAME
          DB_USER: !Ref DBUSER
          DB_PASS: !Ref DBPASS
          INIT_LAMBDA_ARN: !GetAtt InitDBLambda.Arn
      Layers:
        - !Ref Pg8000Layer
      Code:
        ZipFile: |
          import json
          import os
          import pg8000
          import datetime
          from decimal import Decimal
          import boto3

          def handler(event, context):
              try:
                  conn = pg8000.connect(
                      user=os.environ['DB_USER'],
                      password=os.environ['DB_PASS'],
                      host=os.environ['DB_HOST'],
                      database=os.environ['DB_NAME'],
                      port=5432
                  )
                  
                  cursor = conn.cursor()
                  cursor.execute("SELECT * FROM products ORDER BY created_at DESC")
                  rows = cursor.fetchall()
                  cursor.close()

                  columns = ["product_id", "name", "price", "stock", "description", "created_at", "updated_at"]

                  products = []
                  for row in rows:
                      product = dict(zip(columns, row))
                      
                      # Convertir todos los tipos Decimal a float
                      for key, value in product.items():
                          if isinstance(value, Decimal):
                              product[key] = float(value)
                      
                      # Convertir fechas a string ISO
                      for field in ['created_at', 'updated_at']:
                          if product[field] and isinstance(product[field], (datetime.datetime, datetime.date)):
                              product[field] = product[field].isoformat()
                      
                      products.append(product)

                  return {
                      'statusCode': 200,
                      'headers': {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key',
                          'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS'
                      },
                      'body': json.dumps(products, default=str)
                  }
                  
              except Exception as e:
                  error_msg = str(e)
                  
                  # Detectar si es error de tabla no existe
                  if "relation \"products\" does not exist" in error_msg:
                      print("Tabla no encontrada. Inicializando base de datos...")
                      
                      try:
                          # Llamar a la lambda de inicialización
                          lambda_client = boto3.client('lambda')
                          response = lambda_client.invoke(
                              FunctionName=os.environ['INIT_LAMBDA_ARN'],
                              InvocationType='RequestResponse'
                          )
                          
                          init_result = json.loads(response['Payload'].read())
                          
                          if init_result.get('statusCode') == 200:
                              # Reintentar la consulta después de la inicialización
                              conn = pg8000.connect(
                                  user=os.environ['DB_USER'],
                                  password=os.environ['DB_PASS'],
                                  host=os.environ['DB_HOST'],
                                  database=os.environ['DB_NAME'],
                                  port=5432
                              )
                              
                              cursor = conn.cursor()
                              cursor.execute("SELECT * FROM products ORDER BY created_at DESC")
                              rows = cursor.fetchall()
                              cursor.close()

                              columns = ["product_id", "name", "price", "stock", "description", "created_at", "updated_at"]
                              products = []
                              
                              for row in rows:
                                  product = dict(zip(columns, row))
                                  for key, value in product.items():
                                      if isinstance(value, Decimal):
                                          product[key] = float(value)
                                  for field in ['created_at', 'updated_at']:
                                      if product[field] and isinstance(product[field], (datetime.datetime, datetime.date)):
                                          product[field] = product[field].isoformat()
                                  products.append(product)

                              return {
                                  'statusCode': 200,
                                  'headers': {
                                      'Content-Type': 'application/json',
                                      'Access-Control-Allow-Origin': '*',
                                      'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key',
                                      'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS'
                                  },
                                  'body': json.dumps(products, default=str)
                              }
                          else:
                              return init_result
                              
                      except Exception as init_error:
                          return {
                              'statusCode': 500,
                              'headers': {
                                  'Content-Type': 'application/json',
                                  'Access-Control-Allow-Origin': '*',
                                  'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key',
                                  'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS'
                              },
                              'body': json.dumps({'error': f'Error durante inicialización: {str(init_error)}'})
                          }
                  
                  # Si es otro error, devolver normalmente
                  return {
                      'statusCode': 500,
                      'headers': {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key',
                          'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS'
                      },
                      'body': json.dumps({'error': f'Database error: {error_msg}'})
                  }
              finally:
                  if 'conn' in locals():
                      conn.close()

Outputs:
  CreateProductLambdaArn:
    Description: ARN de la Lambda Create
    Value: !GetAtt CreateProductLambda.Arn

  UpdateProductLambdaArn:
    Description: ARN de la Lambda Update
    Value: !GetAtt UpdateProductLambda.Arn

  DeleteProductLambdaArn:
    Description: ARN de la Lambda Delete
    Value: !GetAtt DeleteProductLambda.Arn

  GetAllProductsLambdaArn:
    Description: ARN de la Lambda GetAll
    Value: !GetAtt GetAllProductsLambda.Arn

  InitDBLambdaArn:
    Description: ARN de la Lambda de Inicialización
    Value: !GetAtt InitDBLambda.Arn